#!/bin/sh
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.

ROOT=${PKG_INSTALL_ROOT:-/}
SYSTEM=${ROOT}/etc/system
BOOTENVRC=${ROOT}/boot/solaris/bootenv.rc
PATH_TO_INST=${ROOT}/etc/path_to_inst
POWER_CONF=${ROOT}/etc/power.conf
BAK=bak
TMP=/tmp
NV_SATA=nv_sata
NVSATA_TMP=$TMP/${NV_SATA}
SYSTEM_BAK=${NVSATA_TMP}/system.${BAK}
BOOTENVRC_BAK=${NVSATA_TMP}/bootenv.rc.${BAK}
POWER_CONF_BAK=${NVSATA_TMP}/power.conf.${BAK}
UPGRADE_LOG=${ROOT}/var/sadm/system/logs/upgrade_log
LIVEUPGRADE_TMP_LOG=$TMP/.luupgrade.pfinstall.log.*
DEVMAP_TABLE=${TMP}/devmap_table
DRIVER_ALIASES='"pci10de,37f" "pci10de,55" "pci10de,54" "pci10de,266" "pci10de,267"'
ETC_DEV_DIR=${ROOT}/etc/dev
ENUMERATE_RESERVED=${ETC_DEV_DIR}/reserved_devnames
DEVLINK_DB=${ETC_DEV_DIR}/.devlink_db

CP=/usr/bin/cp
MV=/usr/bin/mv
LN=/usr/bin/ln
LS=/usr/bin/ls
GREP=/usr/bin/grep
SED=/usr/bin/sed
CUT=/usr/bin/cut
CAT=/usr/bin/cat
NAWK=/usr/bin/nawk
RM=/usr/bin/rm
MKDIR=/usr/bin/mkdir
MOUNT=/usr/sbin/mount
MODINFO=/usr/sbin/modinfo
PRTCONF=/etc/prtconf
PRTCONF_OUT=${NVSATA_TMP}/prtconf_vp.out
DEV_PROPS=${NVSATA_TMP}/dev_props.out

#
# get_devinfo_prop(file, prop)
#
#   <prtconf.out> file that has output from 'prtconf -vp' command
#   <prop>  name of the property OR "ALL" for all properties
#
# parse the output of prtconf command and print the value of
# of the specified property or all if <prop> is "ALL" in
# the format "<name>=<value>".
#
get_devinfo_prop()
{
    /bin/cat $1 | ${NAWK} -v prop=$2 '
	BEGIN {
		if (match(prop,"ALL"))
			check_all=1;
		else
			check_all=0;
	}
	{
		if (!match($1, "name="))
			next;
		if (!check_all) {
			pname = sprintf("name=\047%s\047", prop);
			if (!match($1, pname))
				next;
		}
		gsub("\047", "", $1);
		name = substr($1, index($1,"=")+1);
		if (match($2, "type=boolean")) {
			value=1;
		} else if (match($2, "type=int") || match($2, "type=byte")) {
			getline;
			value = ""
			cnt = split(substr($0,index($0, "=")+1), words, ".");
			for (i = 1; i <= cnt; i++) {
				w = "0x" skipzeros(words[i]);
				if (i > 1)
					value = value " ";
				value = value w;
			}
		} else {
			getline;
			value = substr($0,index($0, "=")+1);
		} 
		if (!check_all) {
			print value;
			exit (0);
		}
		print name "=" value;
	}
	# skp the leading '0' characters in the string
	function skipzeros (str, out, n, i)
	{
		n = length(str);
		for (i = 1; i <= n; i++) {
			if (!match(substr(str, i, 1), "0")) {
				break;
			}
		}
		if (i > n)
			out=substr(str,n);
		else
			out=substr(str,i);
		return (out);
	}'
}

#
# Function get_properties() gets the following properties for the
# device (i.e /devices path without '/devices' prefix) passed as
# an argument:
#
#	vendor-id
#	device-id
#	subsystem-vendor-id
#	subsystem-id
#
# Note: it saves the pathname and the properties in ${DEV_PROPS} file 
# to optimize subsequent mapping calls for the same path name.
#
# e.g: get_properties "/pci@0,0/pci-ide@1f,2"
#
get_properties()
{
    if [ -f ${DEV_PROPS} ]
    then
	mapped_path=`${GREP} $1 ${DEV_PROPS}`
	if [ $? -eq 0 ]
	then
		vendor_id=`echo ${mapped_path} | ${CUT} -d ' ' -f2` 
		device_id=`echo ${mapped_path} | ${CUT} -d ' ' -f3` 
		subsystem_vendor_id=`echo ${mapped_path} | ${CUT} -d ' ' -f4` 
		subsystem_id=`echo ${mapped_path} | ${CUT} -d ' ' -f5` 
		return;
	fi
    fi

    path=`echo $1|${GREP} -v storage`
    ${PRTCONF} -v "/devices"$path >${PRTCONF_OUT}
    if [ $? -eq 0 ]
    then
	vendor_id=`get_devinfo_prop ${PRTCONF_OUT} "vendor-id" | ${SED} "s/^0x//"`
	device_id=`get_devinfo_prop ${PRTCONF_OUT} "device-id" | ${SED} "s/^0x//"`
	subsystem_vendor_id=`get_devinfo_prop ${PRTCONF_OUT} "subsystem-vendor-id" | ${SED} "s/^0x//"`
	subsystem_id=`get_devinfo_prop ${PRTCONF_OUT} "subsystem-id" | ${SED} "s/^0x//"`
	rm -f ${PRTCONF_OUT}
	echo $1 "$vendor_id" "$device_id" "$subsystem_vendor_id" "$subsystem_id" >>${DEV_PROPS}
    else
	vendor_id=""
	device_id=""
	subsystem_vendor_id=""
	subsystem_id=""
	echo $1 "$vendor_id" >>${DEV_PROPS}
    fi
}

#
# Function process_bootenvrc_for_install() converts bootpath in ata style
# to nv_sata style in the file /boot/solaris/bootenv.rc for normal upgrade.
#
process_bootenvrc_for_install() {

	# Check to see if bootenv.rc file has ata disk entries.
	${GREP} "cmdk@" ${BOOTENVRC} > /dev/null
	if [ $? -eq 1 ]
	then
		# There is no ata disk entry. No mapping is needed.
		return 0
	fi

	# Backup the bootenv.rc file.
	$CP ${BOOTENVRC} ${BOOTENVRC_BAK}
	if [ $? -ne 0 ]
	then
		# Can't backup bootenv.rc file.
		rem_drv -b ${ROOT} nv_sata
		${RM} -rf ${NVSATA_TMP}
		exit 1
	fi
 
	${GREP} "cmdk@" ${BOOTENVRC} | while read bootpath_line
	do
		old_path=`echo ${bootpath_line} | ${CUT} -d' ' -f3 \
			|$SED "s/\'//g"`
		devname=`echo ${old_path} | $CUT -d/ -f4- | $SED "{
			s/ide@/disk@/
			s/\/cmdk@.//
			}"`
		$LS -l /dev/dsk | $GREP ${devname} | while read line
		do
			new_path=`echo $line | $NAWK '{print $11}'`
			arg="/`echo ${new_path} | ${CUT} -d/ -f4,5`"
			get_properties ${arg}
	
			for pair in ${DRIVER_ALIASES}
			do
				VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
					| $CUT -d, -f1`
				DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
					| $CUT -d, -f2`
				# Check to see if it is a nv_sata device.
				if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
					${device_id} = ${DEVICE_ID} ]
				then	
					if [ "X${subsystem_vendor_id}" = "X" ]
					then
                       				ids="pci${vendor_id},${device_id}"
					else
                       				ids="pci${subsystem_vendor_id},${subsystem_id}"
					fi
					mapped_path=`echo ${old_path} | ${SED} "{
						s/pci-ide/${ids}/
						s/ide/disk/
						s/\/cmdk@.//
						}"`
					new_path="/`echo ${new_path} | $CUT -d/ -f4-`"
					if [ ${new_path} = ${mapped_path} ]
					then
						if [ ! -f ${NVSATA_TMP}/bootenv.rc ]
						then
							$GREP -v "cmdk@" ${BOOTENVRC} > \
								${NVSATA_TMP}/bootenv.rc	
						fi
						echo "setprop bootpath ${new_path}" \
							>> ${NVSATA_TMP}/bootenv.rc
						break	
					fi	
				fi	
			done
		done
	done
	# Commit the changes
	if [ -f ${NVSATA_TMP}/bootenv.rc ]
	then
		${CP} ${NVSATA_TMP}/bootenv.rc ${BOOTENVRC}
		if [ $? -ne 0 ]
		then
			# Failed to modify bootenv.rc file.
			rem_drv -b ${ROOT} nv_sata
			${RM} -rf ${NVSATA_TMP}
			exit 1
		fi
	fi
}

#
# Function process_bootenvrc_for_lu() converts bootpath in ata style
# to nv_sata style in the file /boot/solaris/bootenv.rc for live upgrade.
#
process_bootenvrc_for_lu() {

        # Check to see if bootenv.rc has ata disk entries.

        ${GREP} "cmdk@" ${BOOTENVRC} > /dev/null
        if [ $? -eq 1 ]
        then
                # There is no ata disk. No mapping is needed.
                return 0
        fi

	# Backup the bootenv.rc file.
	$CP ${BOOTENVRC} ${BOOTENVRC_BAK}
	if [ $? -ne 0 ]
	then
		# Can't backup bootenv.rc file.
		rem_drv -b ${ROOT} nv_sata
		${RM} -rf ${NVSATA_TMP}
		exit 1
	fi

	${GREP} "cmdk@" ${BOOTENVRC} | while read bootpath_line
	do
	    bootpath=`echo ${bootpath_line} | ${CUT} -d' ' -f3`
	    if [ "X${no_nvsata_in_CBE}" != "X0" ]
	    then 
        	arg=`echo ${bootpath} | ${CUT} -d/ -f1-3`
        	get_properties ${arg}

        	# Check if boot device is a supported nv_sata device.
        	for pair in ${DRIVER_ALIASES}
        	do
                	dr_vendor_id=`echo $pair | $SED "s/\"//g" | $CUT -d, -f1`
                	dr_device_id=`echo $pair | $SED "s/\"//g" | $CUT -d, -f2`
                	if [ "pci${vendor_id}" = ${dr_vendor_id} -a ${device_id} = \
				${dr_device_id} ]
                	then
				if [ "X${subsystem_vendor_id}" = "X" ]
				then
                       			ids="pci${vendor_id},${device_id}"
				else
                       			ids="pci${subsystem_vendor_id},${subsystem_id}"
				fi
				if [ ! -f ${NVSATA_TMP}/bootenv.rc ]
				then
					$GREP -v "cmdk@" ${BOOTENVRC} > \
						${NVSATA_TMP}/bootenv.rc
				fi
				mapped_bootpath_line=`echo ${bootpath_line} | ${SED} "{
                                	s/pci-ide/${ids}/
                                	s/ide/disk/
                                	s/\/cmdk@.//
                                	}"`

				echo ${mapped_bootpath_line} >> ${NVSATA_TMP}/bootenv.rc
				break
                	fi
        	done
	    else
		is_mapped="no"
		devname=`echo ${bootpath} | $CUT -d/ -f4- | $SED "{
			s/ide@/disk@/
			s/\/cmdk@.//
			}"`
		for new_path in `$LS -l "/dev/dsk" | $GREP ${devname} |$NAWK '{print $11}'`
		do
			arg2="/`echo ${new_path} | ${CUT} -d/ -f4,5`"
			get_properties ${arg2}
			for pair in ${DRIVER_ALIASES}
			do
				VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
					| $CUT -d, -f1`
				DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
					| $CUT -d, -f2`

				# Check to see if it is a nv_sata device.
				if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
					${device_id} = ${DEVICE_ID} ]
				then
					if [ "X${subsystem_vendor_id}" = "X" ]
					then
						ids3="pci${vendor_id},${device_id}"
					else
						ids3="pci${subsystem_vendor_id},${subsystem_id}"
					fi
					mapped_bootpath_line=`echo ${bootpath_line} | ${SED} "{
						s/pci-ide/${ids3}/
						s/ide/disk/
						s/\/cmdk@.//
						 }"`
					mapped_bootpath=`echo ${mapped_bootpath_line} \
						| ${CUT} -d' ' -f3`
					$LS -l "/dev/dsk" | $GREP ${mapped_bootpath} >/dev/null
					if [ $? -eq 0 ]
					then
						if [ ! -f ${NVSATA_TMP}/bootenv.rc ]
						then
							$GREP -v "cmdk@" ${BOOTENVRC} > \
								${NVSATA_TMP}/bootenv.rc
						fi
						echo ${mapped_bootpath_line} >> \
							${NVSATA_TMP}/bootenv.rc	
						is_mapped="yes"
						break
					fi
				fi
			done
			if [ "${is_mapped}" = "yes" ]
			then 
				break
			fi
		done
	    fi
	done
	# Commit the changes
	if [ -f ${NVSATA_TMP}/bootenv.rc ]
	then
		${CP} ${NVSATA_TMP}/bootenv.rc ${BOOTENVRC}
		if [ $? -ne 0 ]
		then
			# Failed to modify bootenv.rc file.
			rem_drv -b ${ROOT} nv_sata
			${RM} -rf ${NVSATA_TMP}
			exit 1
		fi
	fi
}

#
# Function process_system_for_lu() converts rootdev in /etc/system from
# old ata fromat to new nv_sata format during live upgrade.
#
process_system_for_lu() {

        # Check to see if system has ata disk as a root device.
        rootdev_line=`${GREP} -v "*" $SYSTEM | ${GREP} "rootdev:/"| ${GREP} "cmdk@"`
        if [ $? -eq 1 ]
        then
                # roodev entry does not exist, or root disk is not ata.
                return 0
        fi

	${CP} ${SYSTEM} ${SYSTEM_BAK}
	if [ $? -ne 0 ]
	then
		# Can't backup system file."
		$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
		rem_drv -b ${ROOT} nv_sata
		${RM} -rf ${NVSATA_TMP}
		exit 1
	fi

        rootdev=`echo ${rootdev_line} | ${CUT} -d: -f2-`
	if [ "X${no_nvsata_in_CBE}" != "X0" ]
	then
        	ar=`echo ${rootdev} | ${CUT} -d/ -f1-3`
        	get_properties ${ar}

        	# Check if boot device is a supported nv_sata device.
        	for pair in ${DRIVER_ALIASES}
        	do
			dr_vendor_id=`echo $pair | $SED "s/\"//g" | $CUT -d, -f1`
                	dr_device_id=`echo $pair | $SED "s/\"//g" | $CUT -d, -f2`
                	if [ "pci${vendor_id}" = ${dr_vendor_id} -a \
				${device_id} = ${dr_device_id} ]
                	then

				if [ "X${subsystem_vendor_id}" = "X" ]
				then
                       			ids="pci${vendor_id},${device_id}"
				else
                       			ids="pci${subsystem_vendor_id},${subsystem_id}"
				fi
                        	$SED "{
                                	s/pci-ide/$ids/
                                	s/ide/disk/
                                	s/\/cmdk@.//
                                	}" ${SYSTEM} > "${NVSATA_TMP}/system"

                        	break
			fi
        	done
	else
		devname=`echo ${rootdev} | $CUT -d/ -f4- | $SED "{
			s/ide@/disk@/
			s/\/cmdk@.//
			}"`
		is_mapped="no"
		for dev_path in `$LS -l "/dev/dsk" | $GREP ${devname} |$NAWK '{print $11}'`
		do
			ar="/`echo ${dev_path} | ${CUT} -d/ -f4,5`"
			get_properties ${ar}
			for pair in ${DRIVER_ALIASES}
			do
				VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
					| $CUT -d, -f1`
				DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
					| $CUT -d, -f2`

				# Check to see if it is a nv_sata device.
				if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
					${device_id} = ${DEVICE_ID} ]
				then
					if [ "X${subsystem_vendor_id}" = "X" ]
					then
						ids="pci${vendor_id},${device_id}"
					else
						ids="pci${subsystem_vendor_id},${subsystem_id}"
					fi
					
					mapped_rootdev=`echo ${rootdev} | ${SED} "{
						s/pci-ide/${ids}/
						s/ide/disk/
						s/\/cmdk@.//
						}"`		
					$LS -l "/dev/dsk" | $GREP ${mapped_rootdev} >/dev/null
					if [ $? -eq 0 ]
					then
						$SED "{
							s/pci-ide/$ids/
							s/ide/disk/
							s/\/cmdk@.//
							}" ${SYSTEM} > "${NVSATA_TMP}/system"
						is_mapped="yes"	
						break
					fi
				fi
			done
			if [ "${is_mapped}" = "yes" ]
			then
				break
			fi
		done
	fi
	
	if [ -f ${NVSATA_TMP}/system ]
	then
		${CP} ${NVSATA_TMP}/system ${SYSTEM}
		if [ $? -ne 0 ]
		then
			# Failed to modify system file.
			$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
			rem_drv -b ${ROOT} nv_sata
			${RM} -rf ${NVSATA_TMP}
			exit 1
		fi
	fi
}

#
# Function process_system_for_install() converts rootdev in /etc/system from 
# old ata format to new nv_sata format during the upgrade installation.
#
process_system_for_install() {

        # Check to see if system has ata disk as a root device.
	rootdev_line=`${GREP} -v "*" $SYSTEM | ${GREP} "rootdev:/"| ${GREP} "cmdk@"`
        if [ $? -eq 1 ]
        then
		# roodev entry does not exist, or root disk is not ata.
                return 0
        fi

	${CP} ${SYSTEM} ${SYSTEM_BAK}
	if [ $? -ne 0 ]
	then
		# Can't backup system file."
		$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
		rem_drv -b ${ROOT} nv_sata
		${RM} -rf ${NVSATA_TMP}
		exit 1
	fi

	rootdev=`echo ${rootdev_line} | ${CUT} -d: -f2- \
		| $SED "s/\'//g"`
	devname=`echo ${rootdev} | $CUT -d/ -f4- | $SED "{
		s/ide@/disk@/
		s/\/cmdk@.//
		}"`
	is_mapped="no"
	for dev_path in `$LS -l "/dev/dsk" | $GREP ${devname} |$NAWK '{print $11}'`
	do
		arg="/`echo ${dev_path} | ${CUT} -d/ -f4,5`"
		get_properties ${arg}
		for pair in ${DRIVER_ALIASES}
		do
			VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
				| $CUT -d, -f1`
			DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
				| $CUT -d, -f2`

			# Check to see if it is a nv_sata device.
			if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
				${device_id} = ${DEVICE_ID} ]
			then
				if [ "X${subsystem_vendor_id}" = "X" ]
				then
					ids="pci${vendor_id},${device_id}"
				else
					ids="pci${subsystem_vendor_id},${subsystem_id}"
				fi

				mapped_rootdev=`echo ${rootdev} | ${SED} "{
					s/pci-ide/${ids}/
					s/ide/disk/
					s/\/cmdk@.//
					}"`
				$LS -l "/dev/dsk" | $GREP ${mapped_rootdev} >/dev/null
				if [ $? -eq 0 ]
				then
					$SED "{
						s/pci-ide/$ids/
						s/ide/disk/
						s/\/cmdk@.//
						}" ${SYSTEM} > "${NVSATA_TMP}/system"
						is_mapped="yes"
						break
				fi
			fi
		done
		if [ "${is_mapped}" = "yes" ]
		then
			break
		fi
	done

        if [ -f ${NVSATA_TMP}/system ]
        then
                ${CP} ${NVSATA_TMP}/system ${SYSTEM}
                if [ $? -ne 0 ]
                then
                        # Failed to modify system file.
                        $CP ${BOOTENVRC_BAK} ${BOOTENVRC}
                        rem_drv -b ${ROOT} nv_sata
                        ${RM} -rf ${NVSATA_TMP}
                        exit 1
                fi
        fi			
}

#
# Function process_power_conf_for_lu converts ata device path to nv_sata 
# device path if any for live upgrade.
#
process_power_conf_for_lu() {

	$GREP -v "#" ${POWER_CONF} | $GREP "cmdk@">/dev/null
	if [ $? -ne 0 ]
	then
		# No ata device entry in power.conf. No conversion is needed.
		return 0
	fi

	$CP ${POWER_CONF} ${POWER_CONF_BAK}
	if [ $? -ne 0 ]
	then
		# Failed to back up the power.conf file
		$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
		$CP ${SYSTEM_BAK} ${SYSTEM}
		rem_drv -b ${ROOT} nv_sata
		$RM -rf ${NVSATA_TMP}
		exit 1
	fi

	$GREP "#" ${POWER_CONF} > ${NVSATA_TMP}/power.conf
	$GREP -v "#" ${POWER_CONF} | $GREP -v "cmdk@" \
		>> ${NVSATA_TMP}/power.conf

	if [ "X${no_nvsata_in_CBE}" != "X0" ]
	then
		$GREP -v "#" ${POWER_CONF} | $GREP "cmdk@" \
			${POWER_CONF} | while read l
		do
			is_mapped="no"
			new_entry=""
			for i in $l
			do
				tp=$i
				echo $i | $GREP "cmdk@" >/dev/dull
				if [ $? -eq 0 ]
				then
			    		a="/`echo $i | ${CUT} -d/ -f2,3`"
			    		get_properties $a
			   
			    		for pair in ${DRIVER_ALIASES}
			    		do
						dr_vendor_id=`echo $pair | $SED "s/\"//g" \
				    			| $CUT -d, -f1`	
						dr_device_id=`echo $pair | $SED "s/\"//g" \
				    			| $CUT -d, -f2`
						if [ "pci${vendor_id}" = ${dr_vendor_id} -a \
				    			${device_id} = ${dr_device_id} ]
						then
				    			if [ "X${subsystem_vendor_id}" = "X" ]
				    			then
                       						is="pci${vendor_id},${device_id}"
				    			else
                       						is="pci${subsystem_vendor_id},${subsystem_id}"
				    			fi
				    			tp=`echo $i | $SED "{
								s/pci-ide/$is/
								s/ide/disk/
								s/\/cmdk@.//
								}"`
							if [ "${is_mapped}" = "no" ]
							then
								is_mapped="yes"
							fi
				    			break
						fi
			    		done
				fi
				new_entry="${new_entry}$tp "
			done		
			if [ "${is_mapped}" = "yes" ]
			then
				echo ${new_entry} >> ${NVSATA_TMP}/mapped_power.conf
			else
				echo ${new_entry} >> ${NVSATA_TMP}/power.conf
			fi
		done 
	else
        	$GREP -v "#" ${POWER_CONF} | $GREP "cmdk@" ${POWER_CONF} \
			| while read l
        	do
			is_mapped="no"
                	new_entry=""
                	for i in $l
                	do
                        	tp=$i
                        	echo $i | $GREP "cmdk@" >/dev/dull
                        	if [ $? -eq 0 ]
                        	then
                                	dn=`echo $i | $CUT -d/ -f4- | $SED "{
                                        	s/ide@/disk@/
                                        	s/\/cmdk@.//
                                        	}"`
                                	for x in `$LS -l /dev/dsk | $GREP $dn \
                                        	| $NAWK '{print $11}'`
                                	do
                                        	np=""
                                        	a="/`echo ${x} | ${CUT} -d/ -f4,5`"
                                        	get_properties $a
                                        	for pair in ${DRIVER_ALIASES}
                                        	do
                                            		VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
                                                		| $CUT -d, -f1`
                                            		DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
                                                		| $CUT -d, -f2`
                                            		if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
                                                		${device_id} = ${DEVICE_ID} ]
                                            		then
                                                		if [ "X${subsystem_vendor_id}" = "X" ]
                                                		then
                                                    			is="pci${vendor_id},${device_id}"
                                                		else
                                                    			is="pci${subsystem_vendor_id},${subsystem_id}"
                                                		fi
                                                		mapped_path=`echo $i | ${SED} "{
                                                        		s/pci-ide/${is}/
                                                        		s/ide/disk/
                                                        		s/\/cmdk@.//
                                                        		}"`
                                                		np="/`echo ${x} | $CUT -d/ -f4- \
                                                        		| $CUT -d: -f1`"
                                                		if [ ${np} = ${mapped_path} ]
                                                		then
                                                        		tp=${mapped_path}
									if [ "${is_mapped}" = "no" ]
									then
										is_mapped="yes"
									fi	
                                                        		break
								fi
                                            		fi
                                        	done

                                        	if [ "${is_mapped}" = "yes" ]
                                        	then
                                                	break
                                        	fi
                                	done
                        	fi
                        	new_entry="${new_entry}$tp "
                	done
			if [ "${is_mapped}" = "yes" ]
			then
                		echo ${new_entry} >> ${NVSATA_TMP}/mapped_power.conf
			else
				echo ${new_entry} >> ${NVSATA_TMP}/power.conf
			fi	
        	done
	fi

	if [ -f ${NVSATA_TMP}/mapped_power.conf ]
	then
		$CAT ${NVSATA_TMP}/mapped_power.conf >> ${NVSATA_TMP}/power.conf
		$CP ${NVSATA_TMP}/power.conf ${POWER_CONF}
		if [ $? -ne 0 ]
		then
			$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
			$CP ${SYSTEM_BAK} ${SYSTEM}
			rem_drv -b ${ROOT} nv_sata
			$RM -rf ${NVSATA_TMP}
			exit 1
		fi
	fi
}

#
# Function process_power_conf_for_install converts ata device path to nv_sata 
# device path if any for normal upgrade installation.
#
process_power_conf_for_install() {

	$GREP -v "#" ${POWER_CONF} | $GREP "cmdk@" >/dev/null
        if [ $? -ne 0 ]
        then
                # No ata device entry in power.conf. No conversion is needed.
                return 0
        fi

        $CP ${POWER_CONF} ${POWER_CONF_BAK}
        if [ $? -ne 0 ]
        then
		# Failed to back up the power.conf file.
		$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
		$CP ${SYSTEM_BAK} ${SYSTEM}
		rem_drv -b ${ROOT} nv_sata
        	$RM -rf ${NVSATA_TMP}
                exit 1
        fi

	$GREP "#" ${POWER_CONF} > ${NVSATA_TMP}/power.conf
	$GREP -v "#" ${POWER_CONF} | $GREP -v "cmdk@" \
		>> ${NVSATA_TMP}/power.conf

	$GREP -v "#" ${POWER_CONF} | $GREP "cmdk@" ${POWER_CONF} | while read l
        do
		is_mapped="no"
		new_entry=""
		for i in $l
		do
			tp=$i
			echo $i | $GREP "cmdk@" >/dev/dull
			if [ $? -eq 0 ]
			then
				dn=`echo $i | $CUT -d/ -f4- | $SED "{
					s/ide@/disk@/
					s/\/cmdk@.//
					s/\'//g
					}"`
				for x in `$LS -l /dev/dsk | $GREP $dn \
					| $NAWK '{print $11}'`
				do
					np=""
					a="/`echo ${x} | ${CUT} -d/ -f4,5`"
					get_properties $a

					for pair in ${DRIVER_ALIASES}
					do
					    VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
						| $CUT -d, -f1`
					    DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
						| $CUT -d, -f2`
					    if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
						${device_id} = ${DEVICE_ID} ]
					    then
				    		if [ "X${subsystem_vendor_id}" = "X" ]
				    		then
                       				    is="pci${vendor_id},${device_id}"
				    		else
                       				    is="pci${subsystem_vendor_id},${subsystem_id}"
				    		fi
						mapped_path=`echo $i | ${SED} "{
							s/pci-ide/${is}/
							s/ide/disk/
							s/\/cmdk@.//
							}"`
						np="/`echo ${x} | $CUT -d/ -f4- \
							| $CUT -d: -f1`"
						if [ ${np} = ${mapped_path} ]
						then
							tp=${mapped_path}	
							if [ "${is_mapped}" = "no" ]
							then
								is_mapped="yes"
							fi
							break
						fi
					    fi
					done
					
					if [ "${is_mapped}" = "yes" ]
					then
						break
					fi
				done
			fi
			new_entry="${new_entry}$tp "
                done
		if [ "${is_mapped}" = "yes" ]
		then
			echo ${new_entry} >> ${NVSATA_TMP}/mapped_power.conf
		else
			echo ${new_entry} >> ${NVSATA_TMP}/power.conf
		fi
        done

	if [ -f ${NVSATA_TMP}/mapped_power.conf ]
	then
		$CAT ${NVSATA_TMP}/mapped_power.conf >> ${NVSATA_TMP}/power.conf
        	$CP ${NVSATA_TMP}/power.conf ${POWER_CONF}
        	if [ $? -ne 0 ]
        	then
			$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
			$CP ${SYSTEM_BAK} ${SYSTEM}
			rem_drv -b ${ROOT} nv_sata
                	$RM -rf ${NVSATA_TMP}
                	exit 1
        	fi
	fi
}

#
# Function process_devlink_for_lu() links all old ata logical device names
# to new physical device paths on upgraded BE.
#
process_devlink_for_lu() {

        $LS -l "${ROOT}/dev/dsk" | $GREP "cmdk@" | while read line1
        do
                logical_disk=`echo $line1 | $NAWK '{print $9}'`
                old_path=`echo $line1 | $NAWK '{print $11}'`
		mapped_new_path=""
		if [ "X${no_nvsata_in_CBE}" != "X0" ]
		then
                	arg2="/`echo ${old_path} | ${CUT} -d/ -f4,5`"
                	get_properties ${arg2}

                	for pair in ${DRIVER_ALIASES}
                	do
                        	VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
                                	| $CUT -d, -f1`
                        	DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
                                	| $CUT -d, -f2`
                        	# Check to see if it is a nv_sata device.
                        	if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
					${device_id} = ${DEVICE_ID} ]
                        	then
					if [ "X${subsystem_vendor_id}" = "X" ]
					then
                        	    	    ids3="pci${vendor_id},${device_id}"
					else
                        	    	    ids3="pci${subsystem_vendor_id},${subsystem_id}"
					fi
					mapped_new_path=`echo ${old_path} | ${SED} "{
						s/pci-ide/${ids3}/
						s/ide/disk/
						s/\/cmdk@.//
						 }"`
					break
				fi
			done
		else
			devname=`echo ${old_path} | $CUT -d/ -f6- | $SED "{
				s/ide@/disk@/
				s/\/cmdk@.//
				}"`
			is_mapped="no"
			for new_path in `$LS -l "/dev/dsk" | $GREP ${devname} | $NAWK '{print $11}'`
			do
				arg2="/`echo ${new_path} | ${CUT} -d/ -f4,5`"
				get_properties ${arg2}
				for pair in ${DRIVER_ALIASES}
				do
					VENDOR_ID=`echo ${pair} | $SED "s/\"//g" \
						| $CUT -d, -f1`
					DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
						| $CUT -d, -f2`
					
					# Check to see if it is a nv_sata device.
					if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
						${device_id} = ${DEVICE_ID} ]
					then
						if [ "X${subsystem_vendor_id}" = "X" ]
						then
						    ids3="pci${vendor_id},${device_id}"
						else
						    ids3="pci${subsystem_vendor_id},${subsystem_id}"
						fi
						mapped_new_path=`echo ${old_path} | ${SED} "{
							s/pci-ide/${ids3}/
							s/ide/disk/
							s/\/cmdk@.//
							}"`
						if [ ${new_path} = ${mapped_new_path} ]
						then
							is_mapped="yes"
							break
						fi
					fi
				done
				if [ "${is_mapped}" = "yes" ]
				then
					break
				fi
			done
		fi
						
		if [ "X${mapped_new_path}" != "X" ]
		then
			cd ${ROOT}/dev/dsk
			${MV} ${logical_disk} ${logical_disk}.${BAK}
			if [ $? -ne 0 ]
			then
				# Can't back up old link.
				$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
				$CP ${SYSTEM_BAK} ${SYSTEM}
				$CP ${POWER_CONF_BAK} ${POWER_CONF}
				rem_drv -b ${ROOT} nv_sata
                       		${RM} -rf ${NVSATA_TMP}
                       		exit 1
                        fi

			${LN} -s ${mapped_new_path} ${logical_disk}
			if [ $? -ne 0 ]
			then
				# Can't create symbolic link
				${MV} ${logical_disk}.${BAK} ${logical_disk}
                               	$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
				$CP ${SYSTEM_BAK} ${SYSTEM}
				$CP ${POWER_CONF_BAK} ${POWER_CONF}
				rem_drv -b ${ROOT} nv_sata
                                ${RM} -rf ${NVSATA_TMP}
                               	exit 1
			fi
				
			c_number="dsk/`echo ${logical_disk} | $CUT -d'd' -f1`"
			$GREP ${c_number} ${ENUMERATE_RESERVED} >/dev/null
			if [ $? -ne 0 ]
			then
				echo ${c_number} >> ${ENUMERATE_RESERVED}
			fi

			cd ../rdsk
			mapped_new_path="${mapped_new_path},raw"
			${MV} ${logical_disk} ${logical_disk}.${BAK}
			if [ $? -ne 0 ]
			then
                              	# Can't back up old link.
                               	${RM} ../dsk/${logical_disk}
                               	${MV} ../dsk/${logical_disk}.${BAK} \
					../dsk/${logical_disk}
                               	$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
				$CP ${SYSTEM_BAK} ${SYSTEM}
				$CP ${POWER_CONF_BAK} ${POWER_CONF}
				rem_drv -b ${ROOT} nv_sata
                               	${RM} -rf ${NVSATA_TMP}
                               	exit 1
			fi

			${LN} -s ${mapped_new_path} ${logical_disk}
			if [ $? -ne 0 ]
			then
				# Can't create symbolic link.
                               	${MV} ${logical_disk}.${BAK} ${logical_disk}
                               	${RM} ../dsk/${logical_disk}
                               	${MV} ../dsk/${logical_disk}.${BAK} \
                                       	../dsk/${logical_disk}
                               	$CP ${BOOTENVRC_BAK} ${BOOTENVRC}
				$CP ${SYSTEM_BAK} ${SYSTEM}
				$CP ${POWER_CONF_BAK} ${POWER_CONF}
				rem_drv -b ${ROOT} nv_sata
                               	${RM} -rf ${NVSATA_TMP}
                               	exit 1
			fi
               	fi
        done

	$GREP "^dsk" ${ENUMERATE_RESERVED} >/dev/null
	if [ $? -eq 0 ]
        then
                $RM ${DEVLINK_DB}       
        fi
}

#
# Function process_devlink_for_install() links all old ata logical device names
# to new physical device paths for normal upgrade installation.
#
process_devlink_for_install() {

        $LS -l "${ROOT}/dev/dsk" | $GREP "cmdk@" | while read line1
        do
                logical_disk=`echo $line1 | $NAWK '{print $9}'`
		old_path=`echo $line1 | $NAWK '{print $11}' \
			| $SED "s/\'//g"`
		devname=`echo ${old_path} | $CUT -d/ -f6- | $SED "{
			s/ide@/disk@/
			s/\/cmdk@.//
			 }"`
                $LS -l "/dev/dsk" | $GREP ${devname} | while read line2
                do
                        new_path=`echo $line2 | $NAWK '{print $11}'`
                        arg2="/`echo ${new_path} | ${CUT} -d/ -f4,5`"
                        get_properties ${arg2}

			for pair in ${DRIVER_ALIASES}
                        do
                                VENDOR_ID=`echo ${pair} | $SED "s/\"//g"\
                                        | $CUT -d, -f1`
                                DEVICE_ID=`echo ${pair} | $SED "s/\"//g" \
                                        | $CUT -d, -f2`

                                # Check to see if it is a nv_sata device.
                                if [ "pci${vendor_id}" = ${VENDOR_ID} -a \
                                        ${device_id} = ${DEVICE_ID} ]
                                then
					if [ "X${subsystem_vendor_id}" = "X" ]
					then
                        		    ids3="pci${vendor_id},${device_id}"
					else
                        		    ids3="pci${subsystem_vendor_id},${subsystem_id}"
					fi
                                        mapped_new_path=`echo ${old_path} | ${SED} "{
                                                s/pci-ide/${ids3}/
                                                s/ide/disk/
                                                s/\/cmdk@.//
                                                }"`
                                        if [ ${new_path} = ${mapped_new_path} ]
                                        then
                                                # Found the match.
                                                cd ${ROOT}/dev/dsk
                                                ${MV} ${logical_disk} ${logical_disk}.${BAK}
                                                if [ $? -ne 0 ]
                                                then
                                                        # Can't back up old link.
                                                        $CP ${BOOTENVRC_BAK} ${BOOTENVRC}
							$CP ${SYSTEM_BAK} ${SYSTEM}
							$CP ${POWER_CONF_BAK} ${POWER_CONF}
							rem_drv -b ${ROOT} nv_sata
                                                        ${RM} -rf ${NVSATA_TMP}
                                                        exit 1
                                                fi

                                                ${LN} -s ${mapped_new_path} ${logical_disk}
                                                if [ $? -ne 0 ]
                                                then
                                                        # Can't create symbolic link
                                                        ${MV} ${logical_disk}.${BAK} ${logical_disk}
                                                        $CP ${BOOTENVRC_BAK} ${BOOTENVRC}
							$CP ${SYSTEM_BAK} ${SYSTEM}
							$CP ${POWER_CONF_BAK} ${POWER_CONF}
							rem_drv -b ${ROOT} nv_sata
                                                        ${RM} -rf ${NVSATA_TMP}
                                                        exit 1
                                                fi
						
						c_number="dsk/`echo ${logical_disk} \
							| $CUT -d'd' -f1`"
						$GREP ${c_number} ${ENUMERATE_RESERVED} >/dev/null
						if [ $? -ne 0 ]
						then
							echo ${c_number} >> ${ENUMERATE_RESERVED}
						fi

                                                cd ../rdsk
                                                mapped_new_path="${mapped_new_path},raw"
                                                ${MV} ${logical_disk} ${logical_disk}.${BAK}
                                                if [ $? -ne 0 ]
                                                then
                                                        # Can't back up old link.
                                                        ${RM} ../dsk/${logical_disk}
                                                        ${MV} ../dsk/${logical_disk}.${BAK} \
                                                                ../dsk/${logical_disk}
                                                        $CP ${BOOTENVRC_BAK} ${BOOTENVRC}
							$CP ${SYSTEM_BAK} ${SYSTEM}
							$CP ${POWER_CONF_BAK} ${POWER_CONF}
							rem_drv -b ${ROOT} nv_sata
                                                        ${RM} -rf ${NVSATA_TMP}
                                                        exit 1
                                                fi

                                                ${LN} -s ${mapped_new_path} ${logical_disk}
                                                if [ $? -ne 0 ]
                                                then
                                                        # Can't create symbolic link.
                                                        ${MV} ${logical_disk}.${BAK} ${logical_disk}
                                                        ${RM} ../dsk/${logical_disk}
                                                        ${MV} ../dsk/${logical_disk}.${BAK} \
                                                                ../dsk/${logical_disk}
                                                        $CP ${BOOTENVRC_BAK} ${BOOTENVRC}
							$CP ${SYSTEM_BAK} ${SYSTEM}
							$CP ${POWER_CONF_BAK} ${POWER_CONF}
							rem_drv -b ${ROOT} nv_sata
                                                        ${RM} -rf ${NVSATA_TMP}
                                                        exit 1
                                                fi
                                        fi
                                fi
                        done
                done
        done
	
	$GREP "^dsk" ${ENUMERATE_RESERVED} >/dev/null
	if [ $? -eq 0 ]
	then
		$RM ${DEVLINK_DB}	
	fi
}

clean_up() {

        ${RM} -rf ${NVSATA_TMP}
        $LS -l "${ROOT}/dev/dsk" | $GREP "disk@" | while read line
        do
                logical_disk=`echo $line | $NAWK '{print $9}'`
                cd ${ROOT}/dev/dsk
                ${RM} -f ${logical_disk}.${BAK}

                cd ../rdsk
                ${RM} -f ${logical_disk}.${BAK}
        done
}

# Function: check_add_drv()
#
# This function will check if the module has an entry in etc/name_to_major
# If not simply calls add_drv with the arguments given. If there is
# such an entry in name_to_major file, it adds entries in driver_aliases
# driver_classes and minor_perm if necessary.
# The syntax of this function is the same as add_drv. 

check_add_drv()
{
	if [ "$BASEDIR" = "" ]
	then
		BASEDIR=/  
	fi
	alias=""
	class=""
	ADD_ALIAS=0
	ADD_CLASS=0
	ADD_MINOR=0
	OPTIND=1
	IS_NET_DRIVER=0

	cmd="add_drv"

	NO_CMD=
	while getopts i:b:m:c:N  opt
	do
		case $opt in
			N )	NO_CMD=1;;
			i )	ADD_ALIAS=1	
				alias=$OPTARG
				cmd=$cmd" -i '$alias'"
				;;
			m )	ADD_MINOR=1
				minor=$OPTARG
				cmd=$cmd" -m '$minor'"
				;;
			c)	ADD_CLASS=1
				class=$OPTARG
				cmd=$cmd" -c $class"
				;;
			b)	BASEDIR=$OPTARG
				cmd=$cmd" -b $BASEDIR"
				;;
			\?) 	echo "check_add_drv can not handle this option"
				return
				;;
			esac
	done 
	shift `/usr/bin/expr $OPTIND - 1`
	
	drvname=$1

	cmd=$cmd" "$drvname

	drvname=`echo $drvname | /usr/bin/sed 's;.*/;;g'`

	/usr/bin/grep "^$drvname[ 	]" ${ROOT}/etc/name_to_major >  /dev/null 2>&1

	if [ "$NO_CMD" = "" -a $? -ne 0 ] 
	then
		eval $cmd
	else	
		# entry already in name_to_major, add alias, class, minorperm
		# if necessary
		if [ $ADD_ALIAS = 1 ]	
		then
			for i in $alias
			do
				/usr/bin/egrep "^$drvname[ 	]+$i" ${ROOT}/etc/driver_aliases>/dev/null 2>&1
				if [ $? -ne 0 ]
				then
					echo "$drvname $i" >> ${ROOT}/etc/driver_aliases	
				fi
			done
		fi

		if [ $ADD_CLASS = 1 ]
		then
			/usr/bin/egrep "^$drvname[ 	]+$class( |	|$)" ${ROOT}/etc/driver_classes > /dev/null 2>&1
			if [ $? -ne 0 ]
			then 
				echo "$drvname\t$class" >> ${ROOT}/etc/driver_classes
			fi
		fi

		if [ $ADD_MINOR = 1 ]
		then
			/usr/bin/grep "^$drvname:" ${ROOT}/etc/minor_perm > /dev/null 2>&1
			if [ $? -ne 0 ]
			then 
				minorentry="$drvname:$minor"
				echo $minorentry >> ${ROOT}/etc/minor_perm
			fi
		fi

	fi
}

#
# Main program starts here.
#
check_add_drv -b ${ROOT} -i '"pci10de,37f" "pci10de,55" "pci10de,54" "pci10de,266" "pci10de,267"' -m '* 0644 root sys' -c scsi-self-identifying nv_sata

#
# Create temporary directory for node migration 
#
if [ ! -d ${NVSATA_TMP} ]
then
        ${MKDIR} ${NVSATA_TMP}
        if [ $? -ne 0 ]
        then
                # Failed to create ${NVSATA_TMP} directory.
                exit 1
        fi
fi

#
# If it is an install, do nothing. If it is an upgrade, do the conversion.
#
line=`$MOUNT | $GREP "/ "`
first_field=`echo $line | $NAWK '{print $1}'`
third_field=`echo $line | $NAWK '{print $3}'`
echo ${third_field} |$GREP "ramdisk:a" > /dev/null

if [ ${first_field} = "/" -a $? -eq 0 ]
then
	# It is either an install/upgrade.
	if [ -f ${UPGRADE_LOG} ]
	then
		# It is an upgrade.
		$GREP ${NV_SATA} ${PATH_TO_INST} > /dev/null
		if [ $? -eq 0 ]
		then
			# The system was running nv_sata before the upgrade.
			$RM -rf ${NVSATA_TMP}
			exit 0
		fi

		process_bootenvrc_for_install
		process_system_for_install
		process_power_conf_for_install
		process_devlink_for_install
		clean_up
		exit 0
	fi
	$RM -rf ${NVSATA_TMP}
	exit 0
fi

#
# Liveupgrade. 
#
if [ -f ${LIVEUPGRADE_TMP_LOG} ]
then
	$GREP ${NV_SATA} /etc/driver_aliases >/dev/null
	no_nvsata_in_CBE=$?
	$GREP ${NV_SATA} ${PATH_TO_INST} > /dev/null
	if [ $? -eq 0 ]
	then
		# Target BE was running nv_sata driver before the upgrade.
		$RM -rf ${NVSATA_TMP}
		exit 0
	fi	
	process_bootenvrc_for_lu
	process_system_for_lu
	process_power_conf_for_lu
	process_devlink_for_lu
	clean_up
	touch ${ROOT}/reconfigure
	exit 0
fi

#
# Pkgadd.
#
$RM -rf ${NVSATA_TMP}
exit 0
